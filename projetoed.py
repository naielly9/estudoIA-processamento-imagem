# -*- coding: utf-8 -*-
"""ProjetoED.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LSu9EehXjqop8kw2H3SvkPnFi1wl4p15
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import math
import plotly.express as px
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
from mpl_toolkits.mplot3d import Axes3D

relacaoMatriculas_dados = pd.read_excel('/content/Relacao_Matriculas_novosCursos.xlsx')

x = relacaoMatriculas_dados['Cursos'].values.reshape(-1, 1)
y = relacaoMatriculas_dados['Matrículas'].values

# Regressão Linear Simples
reg_simple = LinearRegression()
reg_simple.fit(x, y)

# Coeficientes da regressão
coef_angular = reg_simple.coef_[0]
coef_linear = reg_simple.intercept_

# Imprimir coeficientes
print('Coeficiente Angular:', coef_angular)
print('Coeficiente Linear:', coef_linear)

# Coeficiente de correlação
coef_corr = np.corrcoef(x.squeeze(), y)[0, 1]

print('Coeficiente de correlação:', coef_corr)

# Gráfico de dispersão e reta de regressão
y_pred_simple = reg_simple.predict(x)

plt.scatter(x, y, color='blue', label='Dados')
plt.plot(x, y_pred_simple, color='red', label='Reta de Regressão')
plt.xlabel('Número de Cursos')
plt.ylabel('Número de Matrículas')
plt.legend()
plt.show()

from sklearn.metrics import r2_score
Total_dados = pd.read_excel('/content/Concluintes_Numero_vagas.xlsx')

x1 = Total_dados['Ano'].values.reshape(-1, 1)
x2 = Total_dados['Número de Vagas'].values.reshape(-1, 1)
y = Total_dados['Concluintes'].values

# Combinar X, Y e Z em uma matriz de recursos
X_multi = np.hstack((x1, x2))

reg_multi = LinearRegression()
reg_multi.fit(X_multi, y)

# Predição com regressão linear múltipla
y_pred_multi = reg_multi.predict(X_multi)
r2 = r2_score(y, y_pred_multi)
print('Coeficiente de determinação:',r2)
# Erro padrão (RMSE) para regressão linear múltipla
erroPadrao = np.sqrt(mean_squared_error(y, y_pred_multi))
print('Erro Padrão:', erroPadrao)
# Coeficientes da regressão
coeficientes = reg_multi.coef_
intercepto = reg_multi.intercept_
# Imprimir coeficientes
print('Coeficientes:', coeficientes)
print('intercepto:', intercepto)

# Criação da figura e do subplot 3D
fig = plt.figure(figsize=(20, 6))
ax = fig.add_subplot(111, projection='3d')

# Criação do plano de fundo
x1_min, x1_max = np.min(x1), np.max(x1)
x2_min, x2_max = np.min(x2), np.max(x2)
X1, X2 = np.meshgrid(np.linspace(x1_min, x1_max, 20), np.linspace(x2_min, x2_max, 20))
Z = np.zeros_like(X1)  # Defina a altura do plano como zero (ou qualquer valor desejado)

# Plot do plano de fundo
ax.plot_surface(X1, X2, Z, alpha=0.2)

# Plot dos pontos de dados com legenda
scatter = ax.scatter(x1, x2, y, c='b', marker='o')

# Definição dos rótulos dos eixos
ax.set_xlabel('Ano', color='grey')
ax.set_ylabel('Número de Vagas', color='grey')
ax.set_zlabel('Número de Concluintes', color='grey')

ax.zaxis.set_label_coords(0, 1.1)

# Diminuição do tamanho da fonte dos números dos ticks
ax.tick_params(axis='x', labelsize=13)
ax.tick_params(axis='y', labelsize=13)
ax.tick_params(axis='z', labelsize=13)

# Adicionar legenda
ax.legend()

# Exibição do gráfico
plt.show()

# Frequência da variável "x1"
freq_Concluintes_Numero_vagas = Total_dados['Ano'].value_counts()
print(freq_Concluintes_Numero_vagas)

# Frequência da variável "x2"
freq_Concluintes_Numero_vagas = Total_dados['Número de Vagas'].value_counts()
print(freq_Concluintes_Numero_vagas)

# Frequência da variável "y"
freq_Concluintes_Numero_vagas = Total_dados['Concluintes'].value_counts()
print(freq_Concluintes_Numero_vagas)

sns.boxplot(x=relacaoMatriculas_dados['Cursos'])
plt.xlabel('Cursos')
plt.title('Boxplot da variável Cursos ')
plt.show()


sns.boxplot(x=relacaoMatriculas_dados['Matrículas'])
plt.xlabel('Matrículas')
plt.title('Boxplot da variável Matrículas')
plt.show()

# Nível de confiança (Z)
confianca = 0.95
Z = 1.96

# Margem de erro (E)
E = 0.05

# Estimativa da proporção populacional (p)
p = 0.5

# Cálculo do tamanho mínimo da amostra
n = math.ceil((Z**2*p * (1 - p)) / (E**2))

print(f"Tamanho mínimo da amostra necessário: {n}")